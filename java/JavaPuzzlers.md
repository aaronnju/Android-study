读完了这本书才知道java有这么多不知道的坑，也有很多是我们平时很少用的一些java语言规范。本书每个问题作为一个章节，相互独立，阅读起来很舒服。现把每章节的核心内容摘抄出来，方便查阅。

##Java谜题1——表达式谜题
####1. 奇数性
负数取余操作返回的还是负数，所以不要用这种方式判断奇偶性 i % 2 == 1，用i % 2 != 0

####2. 找零时刻
在需要精确答案的地方，要避免使用float 和double；对于货币计算，要使用int、long 或BigDecimal。因为2.00 - 1.10 ！= 0.9， 是0.8999999。因为并不是所有的小数都可以用二进制浮点数来精确表示的

####3. 长整除
当你在操作很大的数字时，千万要提防溢出，当你拿不准时，就使用long 运算来执行整个计算。
long MICROS_PER_DAY = 24 * 60 * 60 * 1000 * 1000; 尽管计算的结果适合放入long 中，但这个计算完全是以int 运算来执行的，计算已经溢出了。
使用long MICROS_PER_DAY = 24L * 60 * 60 * 1000 * 1000;

####4. 初级问题
在long 型字面常量中，一定要用大写的L，千万不要用小写的l。12345+5432l = 17777 ，not 66666

####5. 十六进制的趣事
避免混合类型（比如左操作数是long 类型的，而右操作数是int 类型的）的计算。十六进制和八进制字面常量无需显式的减号符号就可以表示负的数值。比如0x100000000L + 0xcafebabe的结果不是我们期望的1cafebabe，而是cafebabe。因为0x100000000L是一个负数，它等于十进制数值-889275714。计算过程中，右操作数0xcafebabe 被提升为了long 类型的数值0xffffffffcafebabeL，有符号的整数类型执行的是符合扩展。

####6. 多重转型
从较窄的整型转换成较宽的整型时的符号扩展行为：如果最初的数值类型是有符号的，那么就执行符号扩展；如果它是char，那么不管它将要被转换成什么类型，都执行零扩展。
<strong>byte 是一个有符号的类型</strong>，所以在将byte 数值-1 转换成char（C中char是8bit，有符号的。Java中是16bit无符号的，为了支持unicode） 时，会发生符号扩展。作为结果的char 数值的16 个位就都被置位了，因此它等于2^16-1，即65535。从char 到int 的转型也是一个拓宽原始类型转换println((int)(char)(byte) -1 = 65535

####7. 互换内容
在单个的表达式中不要对相同的变量赋值两次。举的例子是x^= y^= x^= y; 表达式的计算顺序C和java有别。Java 语言规范描述到：操作符的操作数是从左向右求值的，所以上面表达式很难被人理解和口算出正确的结果。

####8：Dos Equis
在条件表达式（？：）中使用类型相同的第二和第三操作数。如果一个操作数的类型是T，T 表示byte、short 或char，而另一个操作数是一个int 类型的<strong>常量表达式</strong> ，它的值是可以用类型T 表示的，那么条件表达式的类型就是T。 否则，将对操作数类型运用二进制数字提升，而条件表达式的类型就是第二个和第三个操作数被提升之后的类型。

####9：半斤
复合赋值操作符（+=、-=、*=、/=、%=、<<=、>>=、>>>=、&=、^=和|=）会悄悄地产生一个转型。如果计算结果的类型宽于变量的类型，那么所产生的转型就是一个危险的窄化转型。相对应的，简单赋值的时候发生窄化转型是非法的。
short x = 0;int i = 123456;
x += i; // 包含了一个隐藏的转型！
x = x + i; // 编译错误

####10：八两
略

##Java谜题2——字符谜题

####11：最后的笑声
使用字符串连接操作符使用格外小心。+ 操作符当且仅当它的操作数中至少有一个是String 类型时，才会执行字符串连接操作；否则，它执行的就是加法。"H"+"a"和'H'+'a'不同。

####12：ABC
char 数组不是字符串。要想将一个char 数组转换成一个字符串，就要调用String.valueOf(char[])方法。不能直接调用数组从Object 那里继承的toString 方法。

####13：畜牧场
在比较对象引用时，你应该优先使用equals 方法而不是 == 操作符，除非你需要比较的是对象的标识而不是对象的值。

####14：转义字符的溃败
在字符串和字符字面常量中要优先选择的是转义字符序列（\'， \n， \t），而不是Unicode 转义字符（\u），Unicode 转义字符可能会因为它们在编译序列中被处理得过早而引起混乱。编译器在将程序解析成各种符号之前，先将Unicode转义字符转换成为它们所表示的字符。

####15：令人晕头转向的Hello
要确保字符\u 不出现在一个合法的Unicode 转义字符上下文之外，即使是在注释中也是如此。这个Unicode 病构的转义字符，编译会失败。

####16：行打印程序
Unicode 转义字符绝对会产生混乱。教训很简单：除非确实是必需的，否则就不要使用Unicode 转义字符。

####17：嗯？
Unicode 转义字符只有在你要向程序中插入用其他任何方式都无法表示的字符时才是必需的，除此之外的任何情况都不应该避免使用它们。Unicode 转义字符降低了程序的清晰度，并且增加了产生bug 的可能性

####18：字符串奶酪
每当你要将一个byte 序列转换成一个String 时，你都在使用某一个字符集，不管你是否显式地指定了它。。如果你想让你的程序的行为是可预知的，那么就请你在每次使用字符集时都明确地指定。
new String(bytes, "ISO-8859-1");

####19：漂亮的火花
块注释不能可靠地注释掉代码段，应该用单行的注释序列来代替。

####20：我的类是什么？
String.replaceAll 接受了一个正则表达式作为它的第一个参数，而并非接受了一个字符序列字面常量。正则表达式“.”可以匹配任何单个的字符， str.replaceAll(".","/")会有意外的结果。类名中的每一个
字符都被替换成了一个斜杠

####21：我的类是什么？II
在使用不熟悉的类库方法时一定要格外小心。当你心存疑虑时，就要求助于Javadoc。
replaceAll("\\.", File.separator)在Windows 上会编译失败，，替代字符串是单独的一个反斜杠，它是无效的。解决方案replaceAll("\\.",Matcher.quoteReplacement(File.separator))或replace(".", File.separator)

####22：URL的愚弄
令人误解的注释和无关的代码会引起混乱。在程序中间出现一条URL是合法的，Java语言认为这个是一个语句标号，不做任何处理。
System.out.print("iexplore:");
http://www.google.com;
System.out.println(":maximize");

####23：不劳无获
首先，要当心栅栏柱错误。如果你要建造一个100 英尺长的栅栏，其栅栏柱间隔为10 英尺，那么你需要多少根栅栏柱呢？11根或9 根都是正确答案，这取决于是否要在栅栏的两端树立栅栏柱，但是10 根却是错误的
其次，牢记在 switch 语句的每一个 case中都放置一条 break 语句。
第三，要使用常用的惯用法和 API，并且当你在离开老路子的时候，一定要参考相关的文档。不要从一个非空的case 向下进入了另一个case
第四，一个 char 不是一个 String，而是更像一个 int。new StringBuffer('M')返回的是一个具有初始容量77 的空的字符串缓冲区

##Java谜题3——循环谜题谜
####24：尽情享受每一个字节
要避免混合类型比较，因为它们内在地容易引起混乱，请使用声明的常量替代“魔幻数字”。
byte b；
if (b == 0x90) ...
0x90 是一个int 常量，它超出了byte 数值的范围。

####25：无情的增量操作
不要在单个的表达式中对相同的变量赋值超过一次。如：j = j++;

####26：在循环中
，这里的教训就是int 不能表示所有的整数。无论你在何时使用了一个整数类型，都要意识到其边界条件。如果其数值下溢或是上溢了，会怎么样呢？
for (int i = START; i <= Integer.MAX_VALUE; i++)
。当i 达到Integer.MAX_VALUE，并且再次被执行增量操作时，它就有绕回到了Integer.MIN_VALUE。

####27：变幻莫测的i值
java移位(<<、>>和>>>)长度是对32 取余的（C++不同），或者如果左操作数是long 类型的，则对64 取余。（-1 << 32）等于-1 而不是0，相当于-1 << 0。移位长度总是介于0 到31 之间，如果左操作数是long 类型的，则介于0 到63 之间。这个长度是对32取余的，如果左操作数是long 类型的，则对64 取余。如果试图对一个int 数值移位32 位，或者是对一个long 数值移位64 位，都只能返回这个数值自身的值。

####28：循环者
我们无法用任何整数类型来表示无穷大，但是用一个double 或一个float 数值来表示无穷大是可以的。比如如果double i = 1.0e40;
While (i == i + 1) {}，则等式将永远成立，无穷大加1 还是无穷大。（对于float 类型，加1 不会产生任何效果的最小级数是2^25，即33,554,432；而对于double 类型，最小级数是2^54，大约是1.8 × 10^16）
这样做之所以可以起作用，是因为一个浮点数值越大，它和其后继数值之间的间隔就越大。浮点数的这种分布是用固定数量的有效位来表示它们的必然结果。
个人的理解是：计算机在表示浮点数的方式如下图，当数值足够大的时候，最后的基数部分将不能很精确的表达浮点数值，他保存的都是他可以表达的最接近的数据。
![screenshot](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/1e99c84a4bd84b08882398d16dfac3bc)
第二点，将一个很小的浮点数加到一个很大的浮点数上时，将不会改变大的浮点数的值

####29：循环者的新娘
float 和double 类型都有一个特殊的NaN（Not a Number） 值，用来表示不是数字的数量。对于所有没有良好的数字定义的浮点计算，例如0.0/0.0，其值都是它.。规范中描述道，NaN 不等于任何浮点数值，包括它自身在内。while (i != i) {} ，如果i=NaN，表达式就永远成立

####30：循环者的爱子
操作符重载是很容易令人误解的。为了使下面表达式永远成立
while (i != i + 0) {}
只需要声明i为String即可。

####31：循环者的鬼魂
不要在short、byte 或char 类型的变量之上使用复合赋值操作符。因为这样的表达式执行的是混合类型算术运算，它容易造成混乱。更糟的是，它们执行将隐式地执行会丢失信息的窄化转型，其结果是灾难性的。所以如何让下面表达式死循环呢？
while (i != 0) {i >>>= 1;}
使用比int 1 更窄的类型的一个负值就好了。short i = -1;通过一次类型提升变成了0xffffffff，一次右移0x7fffffff，一次窄化原始类型转换只剩下(short)oxffff，我们又回到了开始处。

java中有三种移位运算符
"<<" 左移运算符，num << 1,相当于num乘以2
">>" 右移运算符，num >> 1,相当于num除以2
">>>" 无符号右移，忽略符号位，空位都以0补齐

####32：循环者的诅咒
当两个操作数都是被包装的数字类型时，数值比较操作符执行的是值比较，而判等操作符执行的是引用标识的比较。如何将下面的循环转变为一个无限循环：
while (i <= j && j <= i && i != j) {}
答案就是：Integer i = new Integer(0);

####33：循环者遇到了狼人
如何将下面的循环转变为一个无限循环
while (i != 0 && i == -i) {}
Java 使用2 的补码的算术运算，它是非对称的。对于每一种有符号的整数类型（int、long、byte 和short），负的数值总是比正的数值多一个，这个多出来的值总是这种类型所能表示的最小数值。对Integer.MIN_VALUE 取负值得到的还是它没有改变过的值

####34：被计数击倒了
不要使用浮点数作为循环索引，因为它会导致无法预测的行为。
final int START = 2000000000;
for (float f = START; f < START + 50; f++)
其中，(float)2000000000 == 2000000050

####35：一分钟又一分钟
千万不要使用空格来表示分组，要使用括号。空格是靠不住的，而括号是从来不说谎的，
原文举例中使用了表达式ms % 60*1000想达到ms % (60 * 1000)的效果。

##Java谜题4——异常谜题

####36：优柔寡断
每一个finally 语句块都应该正常结束，除非抛出的是不受检查的异常。千万不要用一个return、break、continue 或throw 来退出一个finally 语句块（try-finally），并且千万不要允许将一个受检查的异常传播到一个finally 语句块之外去
static boolean decision() {
try {
return true;
} finally {
return false;
}}
上面程序，try中的return、continue等都会被finally中的覆盖掉。finally 语句块总是在控制权离开try 语
句块时执行的

####37：极端不可思议
1. 对于捕获被检查异常的catch 子句，只有在相应的try 子句可以抛出这些异常时才能编译过
2. 然而特例，任何时候捕获Exception 或Throwble 的catch 子句是合法的，不管与其相对应的try 子句的内容为何。
3.一个方法可以抛出的被检查异常集合是它所继承（实现）的所有类（接口）声明要抛出的被检查异常集合的交集，而不是合集。

####38：不受欢迎的宾客
略

####39：您好，再见！
System.exit 将立即停止所有的程序线程，它并不会使finally 语句块得到调用

####40：不情愿的构造器
当你调用一个构造器时，实例变量的初始化操作将先于构造器的程序体而运行.实例初始化操作抛出的
任何异常都会传播给构造器
public class Reluctant {
private Reluctant internalInstance = new Reluctant();
public Reluctant() throws Exception {
throw new Exception("I'm not coming out");
}
}这段代码会无限递归构造，最后抛出StackOverflowError

####41：域和流
对于任何在finally语句块中可能会抛出的被检查异常都要进行处理，而不是任其传播。比如stream的close方法会抛出IOException，所以在finally里面要捕获这个。

####42：异常为循环而抛
不要使用异常来进行循环控制；应该只为异常条件而使用异常。原文中举例是：循环访问数组，直到越界之后抛出ArrayIndexOutOfBoundsException才终止。

####43：异常地危险
不使用任何不推荐的方法，作者引用的是Thread.stop（Throwable t)，比较生僻的方法。所做的事情正是throw 语句要做的事情，但是它绕过了编译器的所有异常检查操作

####44：切掉类
不要对捕获NoClassDefFoundError 形成依赖，语言规范没有仔细地描述类被加载的时机是在何时发生。。更一般地讲，捕获Error 及其子类型几乎是完全不恰当的。这些异常是为那些不能被恢复的错误而保留的。如果一个类可能丢失或不存在，不要用下面的语句
try {
Missing m = new Missing();
} catch (java.lang.NoClassDefFoundError ex) {
System.out.println("Got it!");
}而应该是
try {
Object m = Class.forName("Missing").
newInstance();
} catch (ClassNotFoundException ex) {
System.err.println("Got it!");
}

####45：令人疲惫不堪的测验
略


##Java谜题5——类谜题
####46：令人混淆的构造器案例
Java 的重载解析过程是以两阶段运行的。第一阶段选取所有可获得并且可应用的方法或构造器。第二阶段在第一阶段选取的方法或构造器中选取最精确的一个。如果一个方法或构造器可以接受传递给另一个方法或构造器的任何参数，那么我们就说第一个方法比第二个方法缺乏精确性
用一个 null 参数来调用 Confusing(Object)构造器或Confusing(double[ ])，程序比较晦涩，构造器
Confusing(Object)可以接受任何传递给 Confusing(double[ ])的参数，最精确的构造器就是Confusing(double[ ])
重载版本的解析可能会产生混淆。应该尽可能地避免重载，如果你必须进行重载，那么你必须遵守上述方针，以最小化这种混淆理想状态下，你应该避免使用重载：为不同的方法取不同的名称。

####47：啊呀！我的猫变成狗了
静态域由声明它的类及其所有子类所共享。如果你需要让每一个子类都具有某个域的单独拷贝，那么你必须在每一个子类中声明一个单独的静态域。

####48：我所得到的都是静态的
对静态方法的调用不存在任何动态的分派机制。当一个程序调用了一个静态方法时，要被调用的方法都是在编译时刻被选定的，而这种选定是基于修饰符的编译期类型而做出的，修饰符的编译期类型就是我们给出的方法调用表达式中圆点左边部分的名字。
总之，要用类名来修饰静态方法的调用，或者当你在静态方法所属的类中去调用它们时，压根不去修饰这些方法，但是千万不要用一个表达式去修饰它们。还有就是要避免隐藏静态方法。所有这些原则合起来就可以帮助我们去消除那些容易令人误解的覆写，这些覆写需要对静态方法进行动态分派

####49：比生命更大
要当心类初始化循环。类初始化循环可能会导致在静态域被初始化之前就调用构造器。
public class Elvis {
public static final Elvis INSTANCE = new Elvis();｝

####50：不是你的类型
instanceof 操作符被定义为在其左操作数为 null 时返回 false
编译失败：如果两个操作数的类型都是类，其中一个必须是另一个的子类型

####51：那个点是什么？
在任何情况下，你都务必要记住：不要在构造器中调用可覆 写的方法。在实例初始化中产生的循环将是致命的。在一个 final 类型的实例域被赋值之前，存在着取用其值的可能，而此时它包含的仍旧是其所属类型的缺省值。

####52：合计数的玩笑
请考虑类初始化的顺序，特别是当初始化显得很重要时更是如此。
类初始化是按照静态初始器在源代码中出现的顺序去执行这些初始器的。

####53：按你的意愿行事
通过本谜题所展示的私有构造器捕获（Private Constructor Capture）惯用法是一种非常有用的模式
public class MyThing extends Thing {
private final int arg;
public MyThing() {
this(SomeOtherClass.func());
}
private MyThing(int i) {
super(i);
arg = i;
}
}

####54：Null 与 Void
略（与谜题 48 的完全相同）

####55：特创论
一个本地变量声明不能被用作 for、while 或 do 循环中的重复执行语句，它作为一条语句只能出现在一个语句块中。另外，在使用一个变量来对实例的创建进行计数时，要使用 long 类型而不是 int 类型的变量，以防止溢出。

##Java 谜题 6——库谜题

####56：大问题
BigInteger 实例是不可变的。String、BigDecimal 以及包装器类型： Integer、 Long、 Short、 Byte、 Character、 Boolean、Float 和 Double 也是如此，你不能修改它们的值。我们不能修改现有实例的值，对这些类型的操作将返回新的实例。警惕add、subtract 和 negate 之类的名字

####57：名字里有什么？
当你覆写 equals 方法时，一定要记着覆写 hashCode 方法。对于大多数在 Object 中声明的非 final 的方法，都需要注意这一点

####58：产生它的散列码
当你想要进行覆写时，千万不要进行重载。为了避免无意识地重载，你应该机械地对你想要覆写的每一个超类方法都拷贝其声明，或者更好的方式是让你的 IDE 帮你去做这些事。
public boolean equals(Name n) 不是Object的equals

####59：什么是差？
千万不要在一个整型字面常量的前面加上一个 0；这会使它变成一个八进制字面常量。012 ！= 12

####60：一行的方法
Java 平台的每一个主版本都在其类库中隐藏了一些宝藏。
每当该平台发布一个新版本时，你都应该研究就一下新特性和提高页面，这样你就不会遗漏掉新版本提供的任何惊喜

####61：日期游戏
在使用 Calendar和 Date 的时候一定要当心，千万要记着查阅 API 文档。这些 API 简直就是雷区。月份使用Calendar.DECEMBER，Calendar.DECEMBER是11而不是12

####62：名字游戏
不要使用 IdentityHashMap，除非你需要其基于标识的语义；它不是一个通用目的的 Map 实现。

####63：更多同样的问题
不要因为偶然地添加了一个返回类型，而将一个构造器声明变成了一个方法声明。
public class MoreNames {
public void MoreNames() {}｝// 只是一个返回值为void 的实例方法。没有任何程序员声明的构造器。

####64：按余数编组
Math.abs 不能保证一定会返回非负的结果。如果它的参数是Integer.MIN_VALUE，或者对于 long 版本的实现传递的是 Long.MIN_VALUE，那么它将返回它的参数。

####65：一种疑似排序的惊人传奇
不要使用基于减法的比较器，除非你能够确保要比较的数值之间的差永远不会大于 Integer.MAX_VALUE 


##Java 谜题 7——更多的类谜题

####66：一件私事
当你在声明一个域、一个静态方法或一个嵌套类型时，如果其名字与基类中相对应的某个可访问的域、方法或类型相同，就会发生隐藏。隐藏是容易产生混乱的：违反包容性的隐藏域在某种意义上是特别有害的。更一般地讲，除了覆写之外，要避免名字重用

一个覆写方法的访问修饰符所提供的访问权限与被覆写方法的访问修饰符所提供的访问权限相比， 至少要一样多

####67：对字符串上瘾
本谜题的教训就是要避免重用类名，尤其是 Java 平台类的类名。千万不要重用 java.lang 包内的类名

####68：灰色的阴影
当一个变量和一个类型具有相同的名字，并且它们位于相同的作用域时，变量名具有优先权。变量名将遮掩（obscure）类型名。相似地，变量名和类型名可以遮掩包名
应该遵守标准的命名习惯以避免不同的命名空间之间的冲突

####69：黑色的渐隐
要解决由类型被变量遮掩而引发的问题，需要按照标准的命名习惯来重命名类型和变量

####70：一揽子交易
一个包内私有的方法不能被位于另一个包中的某个方法直接覆写

####71：进口税
静态导入工具（比如import static java.util.Arrays.toString;）所专门针对的情况是：程序中会重复地使用另一个类的静态元素，而每一次用到的时候都进行限定又会使程序变得乱成一锅粥。
然而，滥用静态导入工具也会损害可读性，因为这会使得静态成员的类在何处被使用显得非常不清晰。

####72：终极危难
要避免在无关的变量或无关的概念之间重用名字。对无关的概念使用有区别的名字有助于让读者和程序员区分这些概念
对于方法，final 意味着该方法不能被覆写（对实例方法而言）或者隐藏（对静态方法而言）
对于域，final 意味着该域不能被赋值超过一次，如果父类和子类存在同一个域，那么将隐藏这个域

####73：你的隐私正在公开
重用名字是危险的；应该避免隐藏、遮蔽和遮掩。

####74：同一性的危机
略
####75：头还是尾？
应该升级到最新的 Java 平台版本上。较新的版本都包含许多让程序员更轻松的改进


##Java 谜题 8——更多的库谜题

####76：乒乓
当你想调用一个线程的 start 方法时要多加小心，别弄错成调用这个线程的 run 方法了

####77：搞乱锁的妖怪
永远不要假设库类会（或者不会）对它的锁做某些事情。为了隔离你自己的程序与库类对锁的使用，除了那些专门设计用来被继承的库类之外，请避免继承其它库类。
Thread.join 方法在表示正在被连接（join）的那个 Thread 实例上调用 Object.wait 方法。这样就在等待期间释放了该对象上的锁。

####78：反射的污染
访问其他包中的非公共类型的成员是不合法的，即使这个成员同时也被声明为某个公共类型的公共成员也是如此。不论这个成员是否是通过反射被访问的，上述规则都是成立的。

####79：这是狗的生活
要小心无意间产生的遮蔽，并且要学会识别表明存在这种情况的编译器错误信息。比如重载sleep（）方法

####80：更深层的反射
考虑到从 Java 程序到 class 文件的映射的复杂度，请避免使用反射来实例化内部类。实例化内部类的时候，必须显示传入一个外部类的引用
Constructor c = Inner.class.getConstructor(Outer.class);
System.out.println(c.newInstance(Outer.this));

####81：烧焦到无法识别
尽可能使用熟悉的惯用法；如果你不得不使用陌生的 API，请一定要参考相关的文档。
System.out 是带有缓冲的
System.out 和 System.err这 2 个流都属于 PrintStream 类型，能够自动刷新，但write(int)是唯一一个在自动刷新(automatic flushing)功能开启的情况下不刷新 PrintStream 的输出方法方法

####82：啤酒爆炸
为了确保子进程能够结束，你必须排空它的输出流；对于错误流（error stream）也是一样，而且它可能会更麻烦，因为你无法预测进程什么时候会倾倒（dump）一些输出到这个流中。调用如下：
Process process = Runtime.getRuntime().exec(COMMAND);
drainInBackground(process.getInputStream());
int exitValue = process.waitFor();
System.out.println("exit value = " + exitValue);

####83：诵读困难者的一神论
实现了 Serializable 的单件类，必须有一个readResolve 方法，用以返回它的唯一的实例。一个次要的教训就是，有可能由于对一个实现了 Serializable 的类进行了扩展，或者由于实现了一个扩展自Serializable 的接口，使得我们在无意中实现了 Serializable。

####84：被粗暴地中断
不要使用 Thread.interrupted 方法，除非你想要清除当前线程的中断状态。如果你只是想查询中断状态，请使用 isInterrupted 方法。

####85：惰性初始化
在类的初始化期间等待某个后台线程很可能会造成死锁。要让类初始化的动作序列尽可能地简单。
public class Lazy {
private static boolean initialized = false;//2 . 主线程会将 initialized 的值设为false
static {
    Thread t = new Thread(new Runnable() {
    public void run() {
// 3. 它也会去检查 Lazy 类是否已经被初始化。这个时候，这个类正在被另外一个线程进行初始化。
// 在这种情况下，当前线程，也就是那个后台线程，会等待 Class 对象直到初始化完成
// 4. 死锁
          initialized = true;
}
});
t.start();
try{
t.join();
}catch (InterruptedException e){
throw new AssertionError(e);
}
}

public static void main(String[] args){
          System.out.println(initialized);//1. 这个类尚未被初始化。记录下当前正在进行初始化，并开始对
这个类进行初始化
}


##Java 谜题 9——高级谜题


####86：有毒的括号垃圾
Integer.MIN_VALUE 是-231，即-2,147,483,648，而 Integer.MAX_VALUE是 231-1，即 2,147,483,647。字面常量 2147483648 只能作为一元负操作符的操作数来使用
int i = -(2147483648)、//编译期错误

####87：紧张的关系
要警惕到 float 和 double 类型的拓宽原始类型转换所造成的损失。
将 int或 long 值转换成 float 值，或 long 值转换成 double 值时，均会导致精度丢失。这种精度丢失可以证明 == 操作符的不可传递性

####88：原生类型的处理
原生类型的成员被擦掉，是为了模拟泛型被添加到语言中之前的那些类型的行为。如果你将原生类型和参数化类型混合使用，那么便无法获得使用泛型的所有好处，而且有可能产生让你困惑的编译错误。另外，原生类型和以 Object为类型参数的参数化类型也不相同。
一个原生类型就是一个没有任何类型参数的泛型类或泛型接口的名字。例如，List<E>是一个泛型接口，List<String> 是一个参数化的类型，而 List 就是一个原生类型。

Pair p = new Pair< Object >   (23, "skidoo");

我们程序中的变量 p 是属于原生类型 Pair 的，所以它的所有实例方法都要执行这种擦除。这也包括声明返回 List<String>的方法 stringList。编译器会将这个方法解释为返回原生类型 List

####89：泛型迷药
泛型类的内部类可以访问到其外围类的类型参数，这可能会使得程序模糊难懂。在一个泛型类中设置一个内部类并不是必错的，但是很少用到这种情况，而且你应该考虑重构你的代码来避免这种情况。当你在一个泛型类中嵌套另一个泛型类时，最好为它们的类型参数设置不同的名字，即使那个嵌套类是静态的也应如此
public class LinkedList<E> {
    private Node<E> head = null;
    private class Node<E> {//编译错误.要订正这个程序，只需要去掉内部类的类型参数即可
            E value;
    ｝
｝
####90：荒谬痛苦的超类
这种一个类既是外部类又是其他类的超类的方式是很不合理的。更一般地讲，扩展一个内部类的方式是很不恰当的；如果必须这样做的话，你也要好好考虑其外部类实例的问题。另外，尽量用静态嵌套类而少用非静态的
内部非静态超类需要下面的写法，不推荐。
public class Outer {
    class Inner1 extends Outer {}
    class Inner2 extends Inner1{
        public Inner2() {
            Outer.this.super();
        }
    }
}

####91：序列杀手
Java 的序列化系统是很脆弱的。为了正确而且高效地序列化大量的类，你必须编写 readObject 或 readResolve 方法

####92：双绞线
私有成员不会被继承


####93：类的战争
常量变量将会被编译进那些引用它们的类中。一个常量变量就是任何被常量表达式初始化的原始类型或字符串变量。令人惊讶的是，null 不是一个常量表达式
前后两个版本的一个类：
V1
public class Words {
    private Words() { }; // Uninstantiable
    public static final String FIRST = "the";
    public static final String SECOND = null;
    public static final String THIRD = "set";
}
V2
public class Words {
    private Words() { }; // Uninstantiable
    public static final String FIRST = "physics";
    public static final String SECOND = "chemistry";
    public static final String THIRD = "biology";
}
重编译了这个类，但并不重编译客户端的程序，客户端都会打印 the chemistry set。

####94：迷失在混乱中
略
####95：只是些甜点
略